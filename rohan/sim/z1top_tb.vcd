$date
	Sat Nov 21 16:54:14 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module z1top_tb $end
$var wire 32 ! D_out [31:0] $end
$var reg 32 " D_in [31:0] $end
$var reg 14 # addr [13:0] $end
$var reg 1 $ clk $end
$var reg 3 % conf [2:0] $end
$var reg 1 & csb $end
$var reg 1 ' out_reg $end
$var reg 1 ( web $end
$scope module unit_sram $end
$var wire 14 ) addr [13:0] $end
$var wire 1 $ clk $end
$var wire 3 * conf [2:0] $end
$var wire 1 & csb $end
$var wire 32 + d_fabric_in [31:0] $end
$var wire 1 ' out_reg $end
$var wire 1 ( web $end
$var wire 1 , web_sync $end
$var wire 32 - w_mask [31:0] $end
$var wire 32 . d_sram_out [31:0] $end
$var wire 32 / d_sram_in [31:0] $end
$var wire 32 0 d_fabric_out [31:0] $end
$var wire 1 1 csb_sync $end
$var wire 9 2 baseaddr_sync [8:0] $end
$scope module smiley $end
$var wire 14 3 addr [13:0] $end
$var wire 1 $ clk $end
$var wire 3 4 conf [2:0] $end
$var wire 1 & csb $end
$var wire 32 5 d_fabric_in [31:0] $end
$var wire 1 ' out_reg $end
$var wire 1 ( web $end
$var wire 32 6 w_mask [31:0] $end
$var wire 5 7 subaddr [4:0] $end
$var wire 32 8 d_sram_out [31:0] $end
$var wire 32 9 d_sram_in [31:0] $end
$var wire 32 : d_fabric_out_noreg [31:0] $end
$var wire 32 ; d_fabric_out [31:0] $end
$var wire 9 < baseaddr [8:0] $end
$var reg 9 = baseaddr_sync [8:0] $end
$var reg 3 > conf_sync [2:0] $end
$var reg 1 1 csb_sync $end
$var reg 32 ? d_fabric_in_sync [31:0] $end
$var reg 32 @ d_fabric_out_reg [31:0] $end
$var reg 5 A subaddr_sync [4:0] $end
$var reg 1 , web_sync $end
$scope module bl_mask_1 $end
$var wire 5 B addr [4:0] $end
$var wire 3 C conf [2:0] $end
$var reg 32 D mask [31:0] $end
$upscope $end
$scope module input_shifter_1 $end
$var wire 32 E D [31:0] $end
$var wire 3 F conf [2:0] $end
$var reg 32 G din [31:0] $end
$upscope $end
$scope module output_shifter_1 $end
$var wire 5 H addr [4:0] $end
$var wire 3 I conf [2:0] $end
$var wire 32 J D [31:0] $end
$var reg 32 K dout [31:0] $end
$upscope $end
$upscope $end
$scope module sram $end
$var wire 9 L addr0 [8:0] $end
$var wire 1 $ clk0 $end
$var wire 1 1 csb0 $end
$var wire 32 M din0 [31:0] $end
$var wire 1 , web0 $end
$var wire 32 N wmask0 [31:0] $end
$var reg 9 O addr0_reg [8:0] $end
$var reg 1 P csb0_reg $end
$var reg 32 Q din0_reg [31:0] $end
$var reg 32 R dout0 [31:0] $end
$var reg 1 S web0_reg $end
$var reg 32 T wmask0_reg [31:0] $end
$scope begin MEM_READ0 $end
$upscope $end
$scope begin MEM_WRITE0 $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx T
xS
bx R
bx Q
xP
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
x1
bx 0
bx /
bx .
bx -
x,
bx +
bx *
bx )
x(
x'
x&
bx %
0$
bx #
bx "
bx !
$end
#2
b0 <
b0 7
0(
0&
b10101010101110111100110011011101 "
b10101010101110111100110011011101 +
b10101010101110111100110011011101 5
b0 #
b0 )
b0 3
b0 %
b0 *
b0 4
0'
#4
b11111111111111111111111111111111 -
b11111111111111111111111111111111 6
b11111111111111111111111111111111 D
b11111111111111111111111111111111 N
b10101010101110111100110011011101 /
b10101010101110111100110011011101 9
b10101010101110111100110011011101 G
b10101010101110111100110011011101 M
b0 >
b0 C
b0 F
b0 I
b0 A
b0 B
b0 H
b0 2
b0 =
b0 L
0,
01
b10101010101110111100110011011101 ?
b10101010101110111100110011011101 E
1$
#8
0$
#10
1&
#12
11
b10101010101110111100110011011101 Q
b0 O
b11111111111111111111111111111111 T
0S
0P
1$
#16
0$
#18
1(
0&
#20
1,
01
1P
1$
#24
0$
#26
0(
b1011111111110101011 "
b1011111111110101011 +
b1011111111110101011 5
#28
b1011111111110101011 /
b1011111111110101011 9
b1011111111110101011 G
b1011111111110101011 M
0,
b1011111111110101011 ?
b1011111111110101011 E
1S
0P
1$
#32
0$
#33
b10101010101110111100110011011101 !
b10101010101110111100110011011101 0
b10101010101110111100110011011101 ;
b10101010101110111100110011011101 :
b10101010101110111100110011011101 K
b10101010101110111100110011011101 .
b10101010101110111100110011011101 8
b10101010101110111100110011011101 J
b10101010101110111100110011011101 R
#34
1(
#36
1,
b10101010101110111100110011011101 @
bx !
bx 0
bx ;
bx :
bx K
bx .
bx 8
bx J
bx R
b1011111111110101011 Q
0S
1$
#40
0$
#42
b111111111 <
b11111 7
b10101010101110111100110011011101 !
b10101010101110111100110011011101 0
b10101010101110111100110011011101 ;
0(
b11111111111111 #
b11111111111111 )
b11111111111111 3
b1 "
b1 +
b1 5
b101 %
b101 *
b101 4
1'
#44
bx !
bx 0
bx ;
b10000000000000000000000000000000 -
b10000000000000000000000000000000 6
b10000000000000000000000000000000 D
b10000000000000000000000000000000 N
b11111111111111111111111111111111 /
b11111111111111111111111111111111 9
b11111111111111111111111111111111 G
b11111111111111111111111111111111 M
bx @
b101 >
b101 C
b101 F
b101 I
b11111 A
b11111 B
b11111 H
b111111111 2
b111111111 =
b111111111 L
0,
b1 ?
b1 E
1S
1$
#48
0$
#49
b0 :
b0 K
b1011111111110101011 .
b1011111111110101011 8
b1011111111110101011 J
b1011111111110101011 R
#50
1(
#52
b0 !
b0 0
b0 ;
1,
b0 @
bx :
bx K
bx .
bx 8
bx J
bx R
b11111111111111111111111111111111 Q
b111111111 O
b10000000000000000000000000000000 T
0S
1$
#56
0$
#60
bx !
bx 0
bx ;
bx @
1S
1$
#64
0$
#65
b11111111111111111111111111111111 :
b11111111111111111111111111111111 K
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx .
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 8
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx J
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx R
#68
b11111111111111111111111111111111 !
b11111111111111111111111111111111 0
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 @
bx :
bx K
bx .
bx 8
bx J
bx R
1$
#72
0$
#73
b11111111111111111111111111111111 :
b11111111111111111111111111111111 K
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx .
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 8
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx J
b1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx R
#74
